#!/bin/zsh

# What the script should do:
# 1. I md5sum every file
# 2. If the checksums are identical, I compare the files
# 3. If 2 or more files are really identical:
#     - move one to a temp-dir
#     - cp --reflink the second to the position and name of the first
#     - do a chown --reference, chmod --reference and touch --reference
#       to copy owner, file mode bits and time from the orginal to the
#       reflink-copy and then delete the original in temp-dir

unset dry
unset verbose
unset yesall
for ((;;)) do
    case $1 in
        -n)
            dry=1 ;;
        -v)
            verbose=1 ;;
        -y)
            yesall=1 ;;
        -*)
            print 'usage: '$0:t' [-n] [-v] [-y] <fs>' ;;
	    exit 2
        *) break ;;
    esac
    shift
done

(( # != 1 )) && exit 2

# checksum all files
# xdev  don't cross filesystems
# links1 skip hard linked files
find $1 -xdev -type f -links 1 -print0 | xargs -0 md5sum > /tmp/md5

# TODO: find hard links as well, but only reflink from them, not to them

sum=0

phy(){
    filefrag -v $1 | fgrep 'ext logical physical' -A1 | tail -1 | tr -s ' ' . | cut -d. -f4
}

# all the files that have a duplicate
dup5s=$(sort /tmp/md5 | uniq -w 32 -d)

# for each duplicated checksum
for md5 in $(cut -c 1-32 <<< $dup5s); do
    # list of files with this checksum
    files=$(grep $md5 /tmp/md5 | cut -c 35-)
    f=(${(f)files})
    unset files
    # position in filesystem of one file
    phy=$(phy $f[1])
    # 0 probably means it doesn't have extents (kept with metadata)
    if (( phy > 0 )); then
        # if all files have same position, then already deduped or hard links
        doit=0
        for file in $f[2,-1]; do
            if (( $(phy $file) != $phy )); then
                doit=1
                break
            fi
        done
        if (( doit == 0 )); then
            continue
        fi
        # show list of files to be deduped
        print
        print -l $f
        if [[ -n $yesall ]] || read -q '?dedup (y/n)? '; then
            for file in $f[2,-1]; do
                p=$(phy $file)
                if (( p != $phy )); then
                    # double-check ; contents may have changed by now
                    if cmp $file $f[1]; then
                        (( sum += $(du -sk $file | cut -f1) ))
                        if [[ -z $dry ]]; then
                            ## guaranteed to be on same filesystem (-xdev), so inode will not change
                            /bin/cp --reflink=always --sparse=auto $f[1] $file
                        else
                            print reflink $f[1] $file
                        fi
                        print sum $sum
                    else
                        print FALSE POSITIVE $file $f[1]
                    fi
                fi
            done
        fi
    fi
done

print $sum k saved
